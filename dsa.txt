#fibonacci series
#1
def fib1(n):
	if n<=1:
		return n
	return fib1(n-1)+fib1(n-2)

#2 with memorization
memo2=[None]*10000
def fib2(n):
	if memo2[n] is not None:
		return memo2[n]
	if n<=1:
		return n
	return fib2(n-1)+fib2(n-2)

#2 computation efficirent
def fib3(n):
	a,b=0,1
	l1=[]
	for _ in range(n):
		l1.append(a)
		a,b=b,a+b
	return l1

#3 generator
def fib4(n):
	a,b=0,1
	for _ in range(n):
		yield a
		a,b =b, a+b


from functools import wraps

def my_decorator(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):   # Accept all positional and keyword args
        print(f"Before calling {fn.__name__}")
        print(f"Positional args: {args}")
        print(f"Keyword args: {kwargs}")
        result = fn(*args, **kwargs)  # Forward them unpacked to the original function
        print(f"After calling {fn.__name__}")
        return result
    return wrapper

@my_decorator
def example_func(a, b=2, *args, c=3, **kwargs):
    print(f"a={a}, b={b}, args={args}, c={c}, kwargs={kwargs}")

# Call with various args:
example_func(1, 5, 7, 8, c=10, d=11, e=12)




def bbsort(array):
    n=len(array)
    for i in range(n):
        swapped=True
        for j in range(0,n-i-1):
           if array[j]>array[j+1]:
              array[j],array[j+1]=array[j+1],array[j]
              swapped=True
        if not swapped:
           break
    return array

def qsort(array):
   if len(array)<2:
      return array
   less=[]
   great=[]
   pivot=array[0]
   for item in array:
     if item<pivot:
        less.append(item)
     else:
        great.append(item)
   return qsort(less)+[pivot]+qsort(great)


#sort the dict based on values
#d1={'a':3,'b':5,'c':2,'d':1,'e':1}
#dict(sorted([(key,value) for key,value in d1.items()],key=lambda item: item[1]))
#

def qsort(array):
  if len(array)<2:
     return array
  pivot=array[0]
  less = []
  great=[]
  for item in array[1:]:
    if item <pivot:
       less.append(item)
    else:
       great.append(item)
  return qsort(less)+[pivot]+qsort(great)

def bbsort(array):
  n=len(array)
  for i in range(n):
     swapped=False
     for  j in range(0,n-i-1)
         if array[j]>array[j+1]:
           array[j], array[j+1]=array[j+1]<array[j]
           swapped=True
     if not swapped:
        break
  return array



